# -*- coding: utf-8 -*-
"""Apuntes de Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GdbjMtjczsd_VWJFfmvmpNL8mBMQC7O8

# **1. CADENA DE TEXTO**

**Print** es universal para cualquier lenguaje de programación
"""

print("Hola TWITCH")
print('Esto también funciona con una comilla simple')

"""Por defecto, el separador que utiliza print de python es un **espacio**."""

print("python", "es", "genial")

"""Podemos cambiar el separador utilizando el parámetro **sep**."""

print("python", "es", "brutal", sep="-")

"""Podemos cambiar el final de la línea utilizando el parámetro **end**."""

print("Hola", end=" ")
print("Mundo")
print("Esto está en la misma línea")

"""### **¿Qué es el corte de cadenas y cómo funciona?**

La segmentación de cadenas permite extraer una parte de una cadena o trabajar solo con una parte específica. Esta es la sintaxis básica:

`string[start:stop]`

Si se desea extraer caracteres de un determinado índice a otro, simplemente se separan los índices start y stop con dos puntos:
"""

my_str = 'Hello world'
print(my_str[1:4]) # ell

"""Ten en cuenta que el stop no es inclusivo, por lo que [1:4] solo se extraen los caracteres del índice 1 y hasta el carácter del índice, pero sin incluir el 4.

También se puede omitir los índices start y stop, y Python usará por defecto 0, o el final de la cadena, respectivamente (-1). Por ejemplo, esto es lo que ocurre si omites el startíndice:
"""

my_str = 'Hello world'
print(my_str[:7])  # Hello w

#Esto extrae todo desde el índice 0hasta (sin incluir) el carácter en el índice 7.

"""Y esto es lo que ocurre si se omite el stopíndice:"""

my_str = 'Hello world'
print(my_str[8:])  # rld

"""Ten en cuenta que cortar una cadena no modifica la cadena original:"""

my_str = 'Hello world'
print(my_str[8:])  # rld
print(my_str)  # Hello world

"""También se puede omitir los índices start y stop, lo que extraerá la cadena completa:"""

my_str = 'Hello world'
print(my_str[:])  # Hello world

"""Además de los índices start y stop, también hay un parámetro opcional llamado `step`, que se utiliza para especificar el incremento entre cada índice en la porción.

Aquí está la sintaxis :

`string[start:stop:step]`

En el siguiente ejemplo, el corte comienza en el índice 0, se detiene antes de 11, y extrae cada segundo carácter:
"""

my_str = 'Hello world'
print(my_str[0:11:2])  # Hlowrd

"""Un truco útil que puedes hacer con el parámetro step es invertir una cadena, estableciendo step en -1 y dejando star ty stop en blanco:"""

my_str = 'Hello world'
print(my_str[::-1]) # dlrow olleH

"""### **¿Cuáles son algunos métodos de cadena comunes?**

Python proporciona varios métodos integrados que facilitan el trabajo con cadenas. Entre ellos se incluyen los siguientes:

- `upper()`:Devuelve una nueva cadena con todos los caracteres convertidos a mayúsculas.
"""

my_str = 'hello world'

uppercase_my_str = my_str.upper()
print(uppercase_my_str)  # HELLO WORLD

"""- `lower()`:Devuelve una nueva cadena con todos los caracteres convertidos a minúsculas."""

my_str = 'Hello World'

lowercase_my_str = my_str.lower()
print(lowercase_my_str)  # hello world

"""- `strip()`: Devuelve una nueva cadena sin los caracteres iniciales ni finales especificados. Si no se pasa ningún argumento, se eliminan los espacios iniciales y finales."""

my_str = '  hello world  '

trimmed_my_str = my_str.strip()
print(trimmed_my_str)  # "hello world"

"""- `replace(old, new)`: Devuelve una nueva cadena con todas las apariciones de old reemplazadas por new."""

my_str = 'hello world'

replaced_my_str = my_str.replace('hello', 'hi')
print(replaced_my_str)  # hi world

"""Se puede usar en cadenas de texto, pero en cambio no se puede usar en LISTAS."""

#Por ejemplo, si queremos sustituir a Ana por Anabel.
testigos=["Serafin", "Lestter", "Ana"]
testigos.replace("Ana", "Anabel") #Esto no estaría bien, ya que de esta manera solo se puede hacer con cadenas de caracteres.
testigos[2]="Anabel" #Esto si estaría bien.

print(testigos)

"""- `split(separator):`Divide una cadena según un separador especificado en una lista de cadenas. Si no se especifica ningún separador, se divide por espacios."""

my_str = 'hello world'

split_words = my_str.split()
print(split_words)  # ['hello', 'world']

"""- `join(iterable)`:Une elementos de un iterable en una cadena con un separador."""

my_list = ['hello', 'world']

joined_my_str = ' '.join(my_list)
print(joined_my_str)  # hello world

"""- `startswith(prefix)`: Devuelve un valor booleano que indica si una cadena comienza con el prefijo especificado."""

my_str = 'hello world'

starts_with_hello = my_str.startswith('hello')
print(starts_with_hello)  # True

"""- `endswith(suffix):` Devuelve un valor booleano que indica si una cadena termina con el sufijo especificado."""

my_str = 'hello world'

ends_with_world = my_str.endswith('world')
print(ends_with_world)  # True

"""- `find(substring)`: Devuelve el índice de la primera aparición de substring, o -1si no encuentra ninguno."""

my_str = 'hello world'

world_index = my_str.find('world')
print(world_index)  # 6

"""- `capitalize()`:Devuelve una nueva cadena con el primer carácter en mayúscula y los demás caracteres en minúscula."""

my_str = 'hello world'

capitalized_my_str = my_str.capitalize()
print(capitalized_my_str)  # Hello world

"""- `isupper()`: Devuelve Truesi todas las letras de la cadena están en mayúsculas y Falsesi no."""

my_str = 'hello world'

is_all_upper = my_str.isupper()
print(is_all_upper)  # False

"""- `islower()`: Devuelve Truesi todas las letras de la cadena son minúsculas y Falsesi no."""

my_str = 'hello world'

is_all_lower = my_str.islower()
print(is_all_lower)  # True

"""- `title()`:Devuelve una nueva cadena con la primera letra de cada palabra en mayúscula."""

my_str = 'hello world'

title_case_my_str = my_str.title()
print(title_case_my_str)  # Hello World

"""# **2. TIPOS DE DATOS**

Nos podemos encontrar con varios tipos de datos como int (enteros), float (con decimales), str, bool, none.
"""

print(10);
print("Este es un tipo de número entero")

"""**¿Cómo se trabaja con números enteros y de punto flotante?**

Los enteros y los números de punto flotante son los principales tipos de datos numéricos en Python. Con ellos, se pueden almacenar datos numéricos y realizar operaciones matemáticas.

Los números enteros son números enteros sin puntos decimales, ya sean positivos o negativos:
"""

my_int_1 = 56
my_int_2 = -4

print(type(my_int_1)) # <class 'int'>
print(type(my_int_2)) # <class 'int'>

"""Podemos utilizar el comando `type()`, para saber el tipo de dato."""

print(type(10))

"""En Python, `isinstance()` es una función integrada que sirve para preguntar: "¿Es este objeto de este tipo de dato?".

Tiene dos partes: el objeto que quieres revisar y el tipo que esperas.

Devuelve True si coinciden y False si no.
"""

def duplicar_numero(dato):
    if isinstance(dato, int): # ¿Es un número entero?
        return dato * 2
    else:
        return "Error: Eso no es un número entero"

print(duplicar_numero(10))    # Resultado: 20
print(duplicar_numero("Hola")) # Resultado: Error...

"""A continuación se explica cómo realizar una operación de **SUMA** con números enteros:"""

my_int_1 = 56
my_int_2 = 12

sum_ints = my_int_1 + my_int_2
print('Integer Addition:', sum_ints) # Integer Addition: 68

"""A continuación se explica cómo realizar una **RESTA** con números enteros:"""

my_int_1 = 56
my_int_2 = 12

# Subtraction
diff_ints = my_int_1 - my_int_2
print('Integer Subtraction:', diff_ints) # Integer Subtraction: 44

"""A continuación se explica cómo realizar una operación de **MULTIPLICACIÓN** con números enteros:"""

my_int_1 = 12
my_int_2 = 4

# Multiplication
product_ints = my_int_1 * my_int_2
print('Integer Multiplication:', product_ints) # Integer Multiplication: 48

"""Y aquí se explica cómo realizar una operación de **DIVISIÓN** con números enteros:"""

my_int_1 = 56
my_int_2 = 12

# Division
div_ints = my_int_1 / my_int_2
print('Integer Division:', div_ints) # Integer Division: 4.666666666666667

"""La suma, resta, multiplicación y división de los float se hará exactamente igual que los integer.

Si suma un entero y un flotante, el resultado se convierte automáticamente en un flotante.

También puede realizar cálculos aritméticos más complejos, como obtener el resto de dos números con el operador módulo, división de piso y exponenciación con números enteros y flotantes.

El **orden de las operaciones (PEMDAS)**En Python, al igual que en las matemáticas, no se opera simplemente de izquierda a derecha.

Existe una jerarquía:

    1ª Paréntesis ()
    2ª Potencia **
    3ª Multiplicación * y División / (tienen la misma prioridad) (Asi que se opera de izquierda a derecha cuando hay dos)
    4ª Suma + y Resta - (tienen la misma prioridad)

2. Resolución paso a paso de un caso práctico $$2 + 3 * 4 / 2

- Paso 1 (Multiplicación): Como la multiplicación y la división están al mismo nivel, se ejecutan de izquierda a derecha.
Primero hacemos $3 * 4 = 12$. La expresión queda: 2 + 12 / 2
- Paso 2 (División): Ahora dividimos $12 / 2 = 6.0$.Importante: En Python, cualquier división con / siempre devuelve un número decimal (float).La expresión queda: 2 + 6.0
- Paso 3 (Suma): Finalmente, sumamos $2 + 6.0 = 8.0$.

- El `operador módulo ( %)` devuelve el resto cuando el valor de la izquierda se divide por el valor de la derecha:
"""

my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

mod_ints = my_int_1 % my_int_2
mod_floats = my_float_2 % my_float_1

print('Integer Modulus:', mod_ints) # Integer Modulus: 8
print('Float Modulus:', mod_floats) # Float Modulus: 1.1999999999999993

"""- La `división de base` divide dos números y devuelve el entero mayor, menor o igual al resultado. Esto se realiza con el operador de doble barra diagonal `( //)`:"""

my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

floor_div_ints = my_int_1 // my_int_2
floor_div_floats = my_float_2 // my_float_1

print('Integer Floor Division:', floor_div_ints) # Integer Floor Division: 4
print('Float Floor Division:', floor_div_floats) # Float Floor Division: 2.0

"""- La `exponenciación` eleva un número a la potencia de otro, y se realiza con el operador de doble asterisco `( **)`:"""

my_int_1 = 56
my_int_2 = 12

my_float_1 = 5.4
my_float_2 = 12.0

exp_ints = my_int_1 ** my_int_2
exp_floats = my_float_1 ** my_float_2

print('Integer Exponentiation:', exp_ints) # Integer Exponentiation: 951166013805414055936
print('Float Exponentiation:',  exp_floats) # Float Exponentiation: 614787626.1765089

"""* **`Tipo complex` (números complejos)**"""

print(3 +4j)

"""* **`Tipo bool (booleanos).`** Siempre que hagamos una operación lógica, el resultado será booleano."""

print(10 > 5)

"""* **Tipo `none` (nulo).** Es un tipo que indica la ausencia de valor."""

def funcion_vacia():
    pass
print(funcion_vacia())

"""* **`Nonetype`** es el tipo de dato que tiene el valor None."""

print(None)

"""- Legibilidad de Números Grandes: En Python, cuando escribes números grandes como 10000.0, puedes usar guiones bajos para que sean más fáciles de leer: 10_000.0. Python los ignorará, pero a tus ojos les encantará.

#### **Casting de tipos de datos.**
Podemos convertir un tipo de dato en otro utilizando las funciones de **CASTING**.
"""

print ("Conversión de tipos de datos");

print(type("100")) #Esto es una cadena de texto porque lo hemos puesto entre comillas.
print(type (100)) #Esto, en cambio, es un entero, pues no está entre comillas.
print(100 + 2) #Esto es una suma de enteros. (El resultado será 102).
print("100" + "2") #Esto es una concatenación de cadenas de texto. (El resultado será 1002).

"""- Podemos convertir una cadena de texto en un entero utilizando la función **`int()`**."""

print(int("100") + 2)

"""  Ahora bien, si es una suma de enteros, entonces el resultado será 1002, ya que lo que hace es unir ambas cadenas de caracteres (100) y (2)."""

print("100" + "2")

"""- A su vez, podemos convertir un entero en una cadena de texto utilizando la función **`str().`**"""

print(str(100) + "2") #Esto es igual que si fuese print ("100" + "2");

"""- La `float()`función devuelve un número de punto flotante construido a partir del número dado:"""

my_int_1 = 56
my_float_1 = float(my_int_1)

print(my_float_1)  # 56.0
print(type(my_float_1))  # <class 'float'>

"""### **Otros métodos para trabajar con float e int**

- `round()`: Redondea un número al número especificado de decimales. Por defecto, esta función redondea al entero más cercano y devuelve un número entero sin decimales.
"""

my_int_1 = 4.798
my_int_2 = 4.253

rounded_int_1 = round(my_int_1)
rounded_int_2 = round(my_int_2, 1)

print(rounded_int_1) # 5
print(rounded_int_2) # 4.3

"""- `abs()`: devuelve el valor absoluto de un número,"""

num = -15

absolute_value = abs(num)
print(absolute_value) # 15

"""- `pow()`: eleva un número a la potencia de otro o realiza una exponenciación modular."""

result_1 = pow(2, 3)  # Equivalent to 2 ** 3
print(result_1)  # 8

result_2 = pow(2, 3, 5)  # (2 ** 3) % 5
print(result_2)  # 3

"""### **Diferencia entre INT Y ROUND**"""

print(int(2.5))

"""De acuerdo al supuesto anterior, convierte el float en int. En este caso, el resultado va a ser 2 (pierde la parte decimal). Es decir, no redondeamos, simplemente eliminamos el decimal. Para redondear, utilizamos la función round()."""

print(round(2.5))

"""Redondea el float al entero más cercano. En este caso, el resultado va a ser 2.

**Pero ojo, que round() redondea al número PAR más cercano en caso de estar justo en el medio, es decir, si es 3.5, redondeará a 4.**

### **Variables**

Solo hace falta escribir el nombre de la variable, y el signo igual (=) para asignarle un valor.
"""

mi_nombre="Serafín";
print(mi_nombre)

"""Las variables se pueden reasignar. Asi que podemos cambiar su valor en tiempo de ejecución, según vamos escribiendo el código.

**Tipado dinámico.** El tipo de dato se determina en tiempo de ejecución. Esto quiere decir que una variable puede cambiar de tipo de dato a lo largo del programa.
"""

mi_variable=10; #mi_variable es un entero.
print(type(mi_variable))
mi_variable="Ahora es una cadena de texto"; #ahora es cadena de texto.
print(type(mi_variable))

"""### **STRING.**

**Los F-STRING.**

Las f-strings (o formatted string literals) son la forma más elegante, rápida y legible de trabajar con texto en Python.

Fueron introducidas en la versión 3.6 y desde entonces se han convertido en el estándar de la industria.

**¿Por qué son tan especiales?**

Antes de las f-strings, unir texto y variables era como armar un rompecabezas complicado usando comas o el símbolo %.

Las f-strings te permiten "inyectar" código directamente dentro de una cadena de texto anteponiendo una letra **f** antes de las comillas.
"""

#ANATOMÍA DE UNA F-STRING.#
producto = "café"
precio = 2.50
# La 'f' mágica al principio le dice a Python: "Busca llaves {}"
mensaje = f"El precio de tu {producto} es ${precio}"
print(mensaje)

"""**Superpoderes de las f-strings**

- Cálculos en tiempo real: Puedes realizar operaciones matemáticas dentro de las llaves.

- Llamar métodos: Puedes transformar texto al vuelo.

- Formateo de números (Clave para finanzas): Puedes decidir cuántos decimales mostrar.

"""

nombre=input("Ingresa tu nombre, por favor: ")
edad=int(input("Ingresa tu edad, por favor: "))

if edad>=18:
    print("Bienbenido al club", nombre)
else:
    print(f"Lo siento {nombre}, vuelve cuando hayan pasado {18-edad} años.")

"""**Operador IN.**

A veces, puede que necesites comprobar si una cadena contiene uno o más caracteres.

Para ello, Python proporciona el operador `in`, que devuelve un valor booleano que especifica si el carácter o los caracteres existen en la cadena.

A continuación se muestran algunos ejemplos:
"""

my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False

"""**Función len().**

Ahora, veamos cómo obtener la longitud de una cadena y trabajar con sus caracteres individuales, un proceso llamado indexación .

Para obtener la longitud de una cadena, se puede usar la función integrada `len()`. A continuación, un ejemplo:
"""

my_str = 'Hello world'
print(len(my_str))  # 11

"""**ÍNDICES**

Cada carácter de una cadena tiene una posición llamada índice. El índice se basa en cero, lo que significa que el índice del primer carácter de una cadena es 0, el del segundo es 1, y así sucesivamente. Para acceder a un carácter por su índice, se utilizan `corchetes ([])` con el índice del carácter al que se desea acceder dentro. Aquí hay algunos ejemplos:
"""

my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

"""### **Los 3 Normalizadores de texto.**

En el mundo real, los usuarios nunca escriben como esperamos: algunos escriben todo en minúsculas, otros en MAYÚSCULAS y otros mEzClAdO.

Si tu programa busca "Serafín" pero el usuario escribe "serafin", el if fallará. Para solucionar esto usamos los métodos de string.

Python nos da herramientas para "limpiar" el texto antes de compararlo o guardarlo:
- **.upper()**: Convierte todo a MAYÚSCULAS.

                  "ana" -> "ANA"

- **.lower()**: Convierte todo a minúsculas. Es el mejor para comparar datos internamente.

                  "ANA" -> "ana"

- **.capitalize()**: Pone la primera letra en mayúscula y el resto en minúscula.

              "sErAfIn" -> "Serafin"

- **.title()**: Pone la primera letra de cada palabra en mayúscula (ideal para nombres completos).

          "juan perez" -> "Juan Perez"
"""

respuesta = input("¿Quieres continuar? (si/no): ").lower().strip()
# .lower() lo pasa a minúsculas
# .strip() elimina espacios accidentales al inicio o final (ej. " si ")
if respuesta == "si":
    print("¡Continuamos!")

nombre_dos = input("¿A quién quería usted traer?: ").capitalize()
if nombre_dos == "Serafín":
    print("¡Anda! Tenemos el mismo nombre.")
#De esta forma, no importa si el usuario escribe "serafin", "SERAFIN" o "SeRaFiN", el método .capitalize() lo convertirá siempre en "Serafin" antes de compararlo.

"""**Conveción de nombres de variables.**"""

mi_nombre_variable="ok"; #snake_case. Minúsculas y guiones bajos entre palabras.
MI_CONSTANTE="valor"; #Mayúsculas para constantes. Valores que no deberían cambiar.

"""También se permite la indexación negativa, por lo que puede obtener el último carácter de cualquier cadena con -1, el penúltimo carácter con -2, y así sucesivamente:"""

my_str = 'Hello world'
print(my_str[-1])  # d
print(my_str[-2]) # l

"""### **Tareas aumentadas.**

La asignación aumentada combina una operación binaria con una asignación en un solo paso. Toma una variable, le aplica una operación con otro valor y almacena el resultado en la misma variable.

Si estás familiarizado con un lenguaje como JavaScript, probablemente hayas oído hablar del operador de asignación de suma ( +=) o de la asignación de resta ( -=), entre otros. Estos también existen en Python. La única diferencia es que se denominan asignaciones aumentadas .

La sintaxis básica de una asignación aumentada se ve así:

`variable <operator>= value`

¿Cuál es una forma más eficiente de hacer esto?

`variable = variable <operator> value`

Por ejemplo, aquí hay un ejemplo de uso de la asignación aumentada para agregar 5a una variable existente:
"""

my_var = 10
my_var += 5

print(my_var) # 15

"""Y aquí está lo mismo, pero sin asignación aumentada:"""

my_var = 10
my_var = my_var + 5

print(my_var) # 15

"""La ventaja de la asignación aumentada es que proporciona una forma concisa y legible de actualizar el valor de una variable sin repetir su nombre. Esto, a su vez, reduce la redundancia y los posibles errores que podrían surgir por errores tipográficos o similares.

Todos los operadores pueden usar una asignación aumentada. Ya vimos el operador de asignación de adición ( +=), así que veamos otros.

- `El operador de asignación de resta ( -=)` resta el operando derecho de la variable izquierda, y almacena la diferencia en la variable izquierda:
"""

count = 14
count -= 3

print(count) # 11

"""- `El operador de asignación de multiplicación ( *=)` multiplica la variable izquierda por el operando derecho y almacena el producto nuevamente en la variable izquierda:"""

product = 65
product *= 7

print(product) # 455

"""- `El operador de asignación de división ( /=)` divide la variable izquierda por la derecha y almacena el resultado nuevamente en la variable izquierda:"""

price = 100
price /= 4

print(price) # 25.0

"""- `El operador de división de piso ( //=)` divide la variable izquierda por la derecha y almacena el resultado nuevamente en la variable izquierda:"""

total_pages = 23
total_pages //= 5

print(total_pages) # 4

"""- `El operador de asignación de módulo ( %=)` calcula el resto de la variable izquierda dividida por la derecha y lo almacena nuevamente en la variable izquierda:"""

bits = 35
bits %= 2

print(bits) # 1

"""- `El operador de asignación de exponenciación ( **=)` eleva la variable izquierda a la potencia de la derecha y almacena el resultado nuevamente en la variable izquierda:"""

power = 2
power **= 3

print(power) # 8

"""También se pueden usar operadores de asignación ampliados con cadenas. Por ejemplo, el operador de asignación de suma facilita la concatenación de cadenas:"""

greet = 'Hello'
greet += ' World'

print(greet) # Hello World

"""Y el operador de asignación de multiplicación se puede utilizar para repetir una cadena:"""

greet = 'Hello'
greet *= 3

print(greet) # HelloHelloHello

"""Otras asignaciones aumentadas generan un error TypeErrorcuando las usas con cadenas:

"""

greet = 'Hello'
greet -= ' World'

print(greet) # TypeError: unsupported operand type(s) for -=: 'str' and 'str'


greet = 'Hello'
greet /= 'World'

print(greet) # TypeError: unsupported operand type(s) for /=: 'str' and 'str'

"""Si te preguntas si los operadores de incremento y decremento ( ++y  --) funcionan en Python, no es así. Esto se debe a que Python evita deliberadamente los atajos de incremento y decremento al estilo C para mantener el lenguaje claro y explícito.

En lugar de x++, puedes simplemente escribir x += 1, lo que hace obvio que estás incrementando el valor de xen 1.

Escribir ++xen Python simplemente aplica el unario más dos veces y no incrementa nada.

# **4.FUNCIÓN DEF.**

La palabra `def` viene de "define" (definir). En Python, no usamos def para ejecutar algo, sino para guardar una receta en la memoria del ordenador.

Imagina que tienes una receta para hacer una tortilla. Escribir la receta en un papel no hace que aparezca una tortilla en tu mesa. Solo cuando decides seguirla (llamar a la función), es cuando realmente cocinas.

**Anatomía de una función**
Para que una función funcione, necesita 4 partes:
1. La palabra def: Le avisa a Python: "¡Atención! Voy a guardar una receta".
2. El nombre: Debe ser descriptivo (ej: calcular_iva, abrir_puerta).
3. Los parámetros (entre paréntesis): Son los ingredientes que la función necesita para trabajar. Pueden ser varios o ninguno.
4. El cuerpo (indentado): El código que se ejecutará cuando uses la función.
"""

def cocinar_huevo(estilo):  # 'estilo' es el parámetro (el hueco)
    print(f"Estoy preparando un huevo {estilo}...")
    print("¡Listo para comer!")

# Aquí termina la función. Nada ha pasado aún en la consola.

# LLAMADA a la función:
cocinar_huevo("frito")  # "frito" es el argumento que rellena el hueco
cocinar_huevo("pasado por agua")

"""**¿Por qué usamos parámetros?**
Los parámetros son como variables locales. Solo existen dentro de la función.

Si miras el ejemplo anterior, estilo no tiene valor hasta que tú llamas a la función. Es como un "espacio reservado". Esto hace que la función sea reutilizable: la misma receta sirve para huevos fritos, cocidos o revueltos.

**Un detalle crucial: El orden**

Python lee de arriba hacia abajo. No puedes llamar a una función antes de haberla definido con def.

❌ ERROR

        saludar()

        def saludar():
            print("Hola")

✅ CORRECTO

        def saludar():
            print("Hola")

        saludar()

La función DEF se compone de la palabra clave def, seguida del nombre que quieres darle a tu función, un par de paréntesis y dos puntos.

Luego, en una nueva línea, escribe el código que debe ejecutar la función. El código que ejecuta la función también se conoce como el cuerpo de la función.

A continuación se muestra un ejemplo de una función personalizada llamada helloque imprime la cadena Hello Worlden la terminal:
"""

def hello():
    print('Hello World')

"""Para ejecutar la función, debes llamarla con su nombre seguido de un par de paréntesis:"""

hello() # Hello World

"""Observe la sangría antes de print('Hello World'). Como recordará de lecciones anteriores, Python utiliza la sangría para determinar qué grupos de sentencias pertenecen entre sí. Estos grupos de sentencias se denominan bloques de código.

Aquí hay otra función simple que imprime la suma de dos números en la terminal:
"""

def calculate_sum(a, b):
    print(a + b)

"""Puedes ver que nuestra función, calculate_sum, tiene a y b entre paréntesis, separados por una coma. Estos se llaman `parámetros`. Piensa en los parámetros como variables de marcador que actúan como "ranuras" para los valores que pasas a las funciones al llamarlas.

Para usar los parámetros, debes pasar "`argumentos`". Los argumentos son los valores que se pasan a una función al llamarla.

Aquí se explica cómo llamar a la calculate_sum función para sumar los números 3y 1:
"""

calculate_sum(3, 1) # 4

"""Si llamas a la función sin el número correcto de argumentos, obtendrás TypeError:"""

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'

"""Las funciones también usan una  clave especial para salir de la función y devolver un valor, que es la palabra `return`. Si no se usa explícitamente return, Python devolverá `None`, un valor por defecto.

He aquí un ejemplo:
"""

def calculate_sum(a, b):
    print(a + b)

my_sum = calculate_sum(3, 1) # 4
print(my_sum) # None

"""Puedes ver que la calculate_sumfunción imprime la suma de ay b, pero no devuelve nada explícitamente. Por lo tanto, cuando asignamos su resultado a my_sum, el valor es en realidad None.

Para solucionarlo, puedes usar la returnpalabra clave para devolver el resultado:
"""

def calculate_sum(a, b):
    return a + b

my_sum = calculate_sum(3, 1)
print(my_sum) # 4

"""Ahora, calculate_sum devuelve la suma de a y b, que se almacena en my_sum.

La diferencia entre print y return
- print(): Es como mostrar un mensaje en una pantalla. Es útil para que tú, como humano, veas lo que pasa, pero el programa no puede "guardar" ese valor para usarlo después.

- return: Es como entregarle un paquete al resto del código. Permite que el resultado de la función se guarde en una variable.

# **3. FUNCIÓN INPUT.**

La función que nos permite pedir datos al usuario.
"""

print("Hola, ¿cómo te llamas?")
usuario1=input()
print(usuario1)

"""Tambien podemos escrbir el mensaje dentro del input."""

usuario=input("¿Cómo te llamas?")
print("Hola", usuario)

"""Input siempre devuelve una cadena de texto. Es decir, el tipo de dato es **str**.

"""

print("¿Qué edad tienes?")
edad=input() #edad va a ser una cadena de texto.

"""Ahora bien, para el supuesto de que queramos o necesitemos que la variable que declaramos sea un **int** o **float** o similar, deberemos de transformarlo previamente."""

print("Dime tu edad, por favor")
edad=input()
print("En un año, tu edad será de ", (int(edad) +1), "años.")
#Convertimos la cadena de texto en entero para poder hacer la suma.
#Es decir, si no hubieramos transformado la edad a entero no habriamos podido hacer la operación ya que era un str.

"""**Para obtener múltiples valores a la vez**"""

country,city=input("¿En qué país y ciudad vives?").split()
print(country, city)
#slpit() divide la cadena de texto en varias partes, separadas por espacios por defecto.
#De esta forma, podemos obtener varios valores a la vez. En la respuesta del usuario, debe haber un espacio entre el país y la ciudad.

"""# **5.SENTENCIAS CONDICIONALES (IF, ELIF).**

* ### **CONDICIONAL IF.**

IF, es poder ejecutar código o bloques de codigo si se cumplen ciertas condiciones.
"""

print("\n Sentencia simple condicional")
edad=18;
if edad >= 18:
    print("Eres mayor de edad")

"""Partes de la sintaxis del código:
- La palabra reservada if. Siempre va al inicio de la sentencia condicional.
- La condición a evaluar (edad>=18). Siempre va seguida de dos puntos(:).
- Si se cumple, se ejecuta el bloque de código indentado (print).

"""

if edad >= 18:
    print("Eres mayor de edad")
else:
    print("No eres mayor de edad") #si no se cumple la condición de if, se ejecuta el else.
    print("Lo siento") #esta línea forma parte del else, porque está indentada.
print("Lo siento") #esta se ejecuta siempre, porque no forma parte del else. No está indentada.

"""En Python, la **indentación** (o sangrado) no es solo una cuestión de estética o de "ordenar el código"; es una regla sintáctica obligatoria. La indentación indica que una o varias líneas de código pertenecen a un "bloque" superior. Si una línea está más a la derecha que la anterior (después de dos puntos :), Python entiende que es parte de esa estructura.

* ## **ELIF**

Se utiliza para evaluar múltiples condiciones.
"""

print("\n Sentencia condicional elif");
nota=4;
if nota<5:
    print("Suspendido")
elif nota>=5 and nota<7:
    print("Aprobado")
elif nota >=7 and nota<9:
    print("Notable")
else:
    print("Sobresaliente")

"""Va leyendo las condiciones una a una, cuando encuentra una que se cumple, ejecuta el código.

Else no es obligatorio

Siempre que utilicemos elementos de comparación (=<<), nos va a devolver un booleano.

* ## **CONDICIONES MÚLTIPLES DE OPERADORES LÓGICOS.**
"""

tiene_carnet=True;
edad=17;
if edad>=18 and tiene_carnet:
    print("Puedes condudcir")
else:
    print("Policia!!")

"""**` CON INPUT Y CONDICIONALES JUNTOS `**"""

print("Introduce tu edad");
edad=input();
tienes_carnet=True;

if int(edad)>=18 and tienes_carnet:
    print("Puedes conducir")
else:
    print("no puedes conducir")

"""

```
LIMPIAR LA CONSOLA
```
"""

import os;
os.systme("clear"); #para limpiar la consola antes de ejecutir el código.

"""# **6.BOOLEANOS.**

Los booleanos son un tipo de dato que solo puede tener dos valores: True (Verdadero) o False (Falso). En Python, son fundamentales para la toma de decisiones, ya que permiten que el programa elija un camino u otro dependiendo de si una condición se cumple o no.

A diferencia de otros lenguajes donde se usa true o false en minúsculas, en Python siempre empiezan con mayúscula:

- True (Representa un 1 lógico)

- False (Representa un 0 lógico)

Si escribes true en minúsculas, Python pensará que estás llamando a una variable que no existe y te dará un error.

En Python, cada valor tiene un valor booleano inherente, o una definición predefinida de si debe tratarse como Trueo Falseen un contexto lógico. Muchos valores se consideran truey , es decir, se evalúan como Trueen un contexto lógico. Otros son falsy , lo que significa que se evalúan como False.

A continuación se muestran algunos valores falsos:

- None
- False
- Entero0
- Flotar0.0
- Cadenas vacías""

Otros valores, como números distintos de cero y cadenas no vacías, son verdaderos.

Si desea comprobar si un valor es verdadero o falso, puede usar la función integrada `bool()`. Esta convierte explícitamente un valor a su equivalente booleano y devuelve True, valores verdaderos, y False, falsos. A continuación, se muestran algunos ejemplos:
"""

print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True

"""## **Operadores lógicos.**

Sirven para combinar varios booleanos. Son esenciales para crear lógica compleja:
- `and (Y)`: Devuelve True solo si ambos son verdaderos.
- `or (O)`: Devuelve True si al menos uno es verdadero.
- `not (NO)`: Invierte el valor (lo que era True pasa a ser False).
"""

#and: devuelve true si ambas condiciones son true.
print(True and True) #True
print(True and False) #False
print(False and False) #False
#or: devuelve True si al menos una de las condiciones es true.
print(True or False) #True
print(False or False) #False
#not: invierte el valor booleano.
print(not True) #False
print(not False) #True

"""Cuando se utilizan varios operadores lógicos en una sentencia if, las condiciones unidas con and se evalúan antes que las unidas con or.

La función **bool()** y la "Verdad" en Python En Python, casi cualquier objeto puede evaluarse como booleano. Existe un concepto llamado Truthy y Falsy:

- Son False: El número 0, las listas vacías [], los strings vacíos "", el valor None y, por supuesto, False.
- Son True: Prácticamente todo lo demás (números distintos de cero, strings con texto, listas con elementos).
"""

#Reglas:
#Cualquier número distinto de 0 es True. El 0 es False.
print(bool(10)) #True
print(bool(0)) #False
#Cualquier cadena de texto no vacía es True. La cadena vacía es False.
print(bool("Hola")) #True
print(bool("")) #False
#Listas, tuplas y diccionarios vacios son False. Si tienen contenido son True.

"""## **Operadores de comparación.**

Comparaciones (Operadores Relacionales)Normalmente, no escribes True directamente, sino que Python lo genera al comparar valores:

Son: **==, !=, <, >, >=, <=.**
- **Diferencia entre = y ==**. El primero es para asignar valores a variables. El segundo es para comparar variables.
- **Comparaciones de cadenas de texto**. Son lexicográficas, es decir, según el orden alfabético.
"""

print("manzana" > "banana") #True, porque la m va después que la b en el alfabeto. No lo compara por la longuitud.

"""## **Condiciones Ternarias.**

Las condiciones ternarias en Python son una forma compacta de escribir una estructura if-else en una sola línea.

A diferencia de otros lenguajes (como C++ o Java) que usan el símbolo ? :, Python utiliza una sintaxis basada en palabras clave que se lee casi como una frase en inglés.

La estructura sigue este orden:

*`resultado_si_verdadero if condicion else resultado_si_falso`*
"""

#Forma tradicional.
edad = 20
if edad >= 18:
    estado = "Adulto"
else:
    estado = "Menor"
print(estado)

#Forma ternaria.
edad = 20
estado = "Adulto" if edad >= 18 else "Menor"
print(estado)

"""# **7.LAS LISTAS.**

Son SECUENCIAS MUTABLES DE ELEMENTOS. Una lista es una colección ordenada de elementos que se encierran entre corchetes [] y se separan por comas. Para crear una lista se utilizan corchetes [], y los elementos se separan por comas.
"""

print("n\ Creación de listas")
mi_lista_cadena=["manzana", "pera", "banana"]; #lista de cadena de textos.
mi_lista_mixta=[1, "manzana", 3.14, True]; #lista mixta. Tiene elementos tanto numéricos como de texto.
lista_vacia=[]; #lista vacia.
lista_de_lista=[[1,2],[3,4]]; #lista de listas (matriz).

"""## **Acceso a los elementos de una lista.**

Existen varias formas de acceder a un elemento concreto de una lista. La forma más sencilla es utilizando el **`índice entre corchetes.`**.
"""

mi_lista_cadena=["manzana", "pera", "banana"];
print(mi_lista_cadena[0]) #Resultado: manzana.

"""Recuerda que en Python (y en la mayoría de lenguajes que verás en DAM), el conteo siempre empieza en 0:
- 0: Primer elemento ("manzana").
- 1: Segundo elemento ("pera").
- 2: Tercer elemento ("banana").

Si intentas acceder a mi_lista_cadena[3], te dará un error de IndexError porque ese índice no existe en una lista de tres elementos.

**Diferencias clave en el uso de paréntesis y corchetes**

- [ ]	Indexación y Slicing: Acceder a un elemento por su posición.	lista[0]
- ( )	Llamada a Funciones: Ejecutar código o pasar argumentos.	print("hola")
- { }Diccionarios y Conjuntos: Estructuras de datos clave-valor.{"id": 1}

Tambien puedes acceder a los índices **`de forma negativa`**. -1 es el último elemento, -2 el penúltimo, etc.
"""

mi_lista_cadena=["manzana", "pera", "banana"];
print(mi_lista_cadena[-1]) #Resultado: banana.

"""Ahora bien, **`¿y si quiero acceder a un elemento dentro de una lista que está dentro de otra lista?`** En ese caso, utilizamos varios índices. Para navegar por listas anidadas (listas dentro de listas), simplemente vas añadiendo "niveles" de corchetes. Cada par de corchetes te permite profundizar una capa más.

**Estructura de acceso**

*`La sintaxis es: lista_principal[indice_sublista][indice_elemento]`*
"""

lista_de_lista=[[1,2],[3,4]]
print(lista_de_lista[0][1]) #Resultado: 2.
print(lista_de_lista[0][0]) #Resultado: 1.

"""## **SLICING de listas.**

El slicing (o rebanado) es una de las características más potentes de Python. Permite extraer secciones de una lista de forma rápida y legible.

La sintaxis básica es:
*`lista[inicio:fin:paso]`*

Los Tres Parámetros
inicio:
- El índice donde comienza la extracción (incluido). Si se omite, por defecto es 0.

- fin: El índice donde termina la extracción (excluido). Si se omite, llega hasta el final.

- paso (opcional): Indica cuántos elementos saltar. Por defecto es 1.

Ejemplo visual del funcionamiento:

Supongamos la lista letras = ['a', 'b', 'c', 'd', 'e'].
"""

numeros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Extraer del índice 2 al 5 (el 5 no se incluye)
print(numeros[2:5])   # Resultado: [2, 3, 4]
# Desde el principio hasta el índice 4
print(numeros[:4])    # Resultado: [0, 1, 2, 3]
# Desde el índice 6 hasta el final
print(numeros[6:])    # Resultado: [6, 7, 8, 9]
# Elementos en posiciones pares (salto de 2)
print(numeros[::2])   # Resultado: [0, 2, 4, 6, 8]
# Invertir la lista completa (truco clásico)
print(numeros[::-1])  # Resultado: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
# Los últimos tres elementos
print(numeros[-3:])   # Resultado: [7, 8, 9]
# Toda la lista excepto el primero y el último
print(numeros[1:-1])  # Resultado: [1, 2, 3, 4, 5, 6, 7, 8]

"""El slicing no modifica la lista original, sino que crea una copia superficial (shallow copy) de la sección solicitada.

## **Modificar una lista.**

1. **Cambiar elementos (Acceso por índice)**
Si conoces la posición del elemento, puedes sobrescribirlo directamente. También puedes usar el slicing para cambiar varios a la vez.
"""

frutas = ["manzana", "pera", "platano"]
# Cambiar un solo elemento
frutas[1] = "kiwi"  # ["manzana", "kiwi", "platano"]
# Cambiar un rango (slicing)
frutas[0:2] = ["fresa", "naranja"] # ["fresa", "naranja", "platano"]

"""2. **Añadir elementos.** Existen tres formas principales dependiendo de dónde quieras colocar el nuevo dato:
    - **.append(item)**: Añade al final de la lista.
    - **.insert(indice, item)**: Añade en una posición específica, desplazando el resto.
    - **.extend(lista)** o **+**: Une una lista con otra.
"""

tareas = ["estudiar"]
tareas.append("programar")      # ["estudiar", "programar"]
tareas.insert(0, "desayunar")   # ["desayunar", "estudiar", "programar"]
tareas.extend(["descansar", "ejercicio"]) # Añade varios al final

"""3. **Eliminar elementos**. Python ofrece varias opciones según si conoces el valor o la posición:

    - **.remove(valor)**	Borra la primera aparición del valor indicado.
    - **.pop(indice)**	Borra y devuelve el elemento en esa posición (por defecto la última)
    - **.del lista[i]**	Palabra clave para borrar por índice o rango.
    - **.clear()**	Vacía la lista por completo.
"""

nums = [10, 20, 30, 40, 20]
nums.remove(20)  # [10, 30, 40, 20] (solo borra el primero)
ultimo = nums.pop() # Borra 20 y lo guarda en la variable 'ultimo'
del nums[0]      # Borra el 10

"""4. **Ordenar y dar la vuelta**
    - **.sort()**: Ordena la lista original (alfabéticamente o numéricamente).
    - **.reverse()**: Invierte el orden de los elementos in-place.
"""

letras = ["c", "a", "b"]
letras.sort()    # ["a", "b", "c"]
letras.reverse() # ["c", "b", "a"]

#Para obtener una nueva lista ordenada, utilizamos la función sorted().
mi_lista_ordenada=sorted(mi_lista); #Devuelve una nueva lista ordenada.

"""5. **Recuperar la LONGITUD DE UNA LISTA**"""

#Consiste en utilizar la función len().
print("Longitud de una lista")
mi_lista=[1,2,3,4,5]
print(len(mi_lista)) #Resultado: 5.

"""## **Métodos de Búsqueda y Reordenación en Listas.**

Los métodos de las listas en Python nos permiten interactuar con el contenido sin necesidad de escribir bucles manuales.

1. **Conteo de Elementos**: **.count(valor)**. Este método busca cuántas veces se repite un elemento específico dentro de la lista.
    - Sintaxis: lista.count(elemento)
    - Retorno: Un número entero (int).
    - Comportamiento: Si el elemento no existe, devuelve 0. No modifica la lista original.
"""

mi_lista = [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4]
print(mi_lista.count(3))  # Resultado: 2 (porque el 3 aparece dos veces)

"""2. **Localización de Índices:** **.index(valor)**. Sirve para saber en qué posición exacta se encuentra un elemento por primera vez.
   - Sintaxis: lista.index(elemento)
   - Retorno: El índice (posición) de la primera aparición.
   - ¡Cuidado!: Si el elemento no existe en la lista, Python lanzará un error tipo ValueError. En entornos reales, solemos verificar primero si el elemento está en la lista con el operador **in**.
"""

# Buscamos el número 4
mi_lista = [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4]
print(mi_lista.index(4))  # Resultado: 3
# Índice: 0  1  2  [3]  4 ...
# Valor:  1  2  3   4   5 ...

"""3. **Inversión de la Lista: .reverse()**.Este método le da la vuelta por completo al orden de la lista.
   - Sintaxis: lista.reverse()
   - Tipo de operación: In-place (esto es fundamental). Significa que modifica la lista original directamente y no devuelve nada (devuelve None).
   - Uso común: Cuando el orden de los datos debe ser cronológicamente inverso o para algoritmos específicos de ordenación.
"""

mi_lista = [1, 2, 3]
mi_lista.reverse()
print(mi_lista)  # Resultado: [3, 2, 1]

"""# **8.BUCLES Y LOOPS.**

## **1. El Bucle for (Iterativo).**

Se utiliza cuando sabes de antemano (o Python lo sabe) cuántas veces se va a repetir la acción. Es ideal para recorrer listas, tuplas o rangos.
"""

# Recorrer una lista
alumnos = ["Ana", "Luis", "Marta"]
for nombre in alumnos:
    print(f"Hola {nombre}")

"""**¿Cómo funciona por dentro?**
Imagina que el bucle es un operario que va sacando objetos de una caja:
1. Primera vuelta: El bucle mira la lista alumnos. Toma el primer elemento ("Ana") y lo guarda automáticamente en la variable temporal nombre. Luego ejecuta el print.
2. Segunda vuelta: Vuelve al inicio, toma el siguiente elemento ("Luis"), actualiza la variable nombre con este nuevo valor y vuelve a ejecutar el print.
3. Tercera vuelta: Toma a "Marta", hace lo mismo.
4. Final: El bucle mira la lista, ve que ya no quedan más elementos y termina automáticamente.

**La función range()**

Es la compañera inseparable del for. Genera una secuencia de números.Range(stop) genera números. Pero tiene un truco: puedes decirle dónde empezar y dónde terminar: range(inicio, fin). *Nota: El número de "fin" nunca se incluye.*
- range(5): 0, 1, 2, 3, 4
- range(2, 6): 2, 3, 4, 5
- range(0, 10, 2): 0, 2, 4, 6, 8 (números pares)
"""

#UN ARGUMENTO.#
for i in range(5):
    print(i)
# Resultado: 0, 1, 2, 3, 4

#DOS ARGUMENTOS.#
for i in range(5, 10):
    print(i)
# Resultado: 5, 6, 7, 8, 9

#TRES ARGUMENTOS.#
# Solo números pares del 0 al 10
for i in range(0, 11, 2): #empieza en 0, y de dos en dos, hasta llegar al 10 [pues el 11 no se cuenta].
    print(i)
# Resultado: 0, 2, 4, 6, 8, 10
# Cuenta atrás (paso negativo)
for i in range(5, 0, -1):
    print(i)
# Resultado: 5, 4, 3, 2, 1

"""`**range vs list**`

Es importante entender que range() no crea una lista real en la memoria del ordenador, sino que es un objeto generador. Esto significa que va creando los números uno a uno según los necesita el bucle, lo cual ahorra muchísima memoria si trabajas con números grandes (por ejemplo, range(1000000)).
"""

#Si alguna vez necesitas convertirlo en una lista de verdad, tienes que forzarlo así:
mi_lista = list(range(1, 6))
print(mi_lista) # [1, 2, 3, 4, 5]

"""**BUCLE FOR PARA STRING.**

Para Python, una palabra (un string) no es solo un bloque de texto sólido. En realidad, Python ve a la palabra "Python" como una colección de caracteres individuales puestos en fila.

Es decir, para el bucle for, la palabra "Python" es casi idéntica a una lista de letras: `["P", "y", "t", "h", "o", "n"]`.

**¿Cómo funciona el for en un String?**
Cuando escribes for letra in "Python":, Python hace este proceso paso a paso:

1. Paso 1: Mira el primer caracter de la cadena: la 'P'.
2. Paso 2: Toma esa 'P' y la guarda en tu variable temporal letra.
3. Paso 3: Ejecuta el print(letra). (Vemos la P en pantalla).
4. Paso 4: Vuelve al inicio, salta al siguiente caracter ('y') y repite el proceso hasta que se acaban las letras.

Hagamos la prueba de fuego.
Si escribes esto:
"""

for letra in "Python":
    print(letra) #Va a imprimir cada una de las letras.

"""Ahora bien, si en cambio escribes esto:"""

for letra in "Python":
    print("Hola") #Va a imprimir 6 veces Hola.

"""### **for con index (Nivel Pro)**

A veces, además de saber que el color es "Rojo", quieres saber que es el primero (posición 1). Para eso usamos una función especial llamada `enumerate()`.

- i guarda el número (0, 1, 2...).
- color guarda el dato ("Rojo", "Verde"...).
"""

colores = ["Rojo", "Verde", "Azul"]

for i, color in enumerate(colores):
    print(f"El color número {i+1} es el {color}")

"""**Un breve repaso visual** antes del siguiente paso. Ya hemos visto casi todas las formas de "iterar" (dar vueltas). Aquí tienes el resumen definitivo de cómo elegir tu bucle for:

- ¿Tengo una lista/palabra? → `for elemento in lista:`
- ¿Quiero repetir algo un número fijo de veces? → `for i in range(numero):`
- ¿Quiero contar de forma especial (atrás, saltando de 2 en 2)? → `for i in range(inicio, fin, salto):`

## **2. El Bucle while (Condicional).**

Se ejecuta mientras una condición sea verdadera ($True$). Es más flexible pero peligroso: si la condición nunca se vuelve falsa, creas un bucle infinito.
"""

contador = 1
while contador <= 5:
    print(f"Vuelta número {contador}")
    contador += 1  # ¡Fundamental! Si no incrementas, nunca para.

"""El `**WHILE TRUE**`, es una de las herramientas más potentes y, a la vez, más peligrosas de Python. Vamos a desmenuzarlo para que lo domines por completo.

Normalmente, un bucle while tiene una condición que Python revisa antes de entrar (como ahorrado < 10000). Pero en un while True, le estamos diciendo a Python: "La condición es 'Verdad', y como 'Verdad' siempre es 'Verdad', entra y no salgas nunca".

1. ¿Por qué querríamos un bucle que no termina?

Parece una locura, ¿verdad? Pero en realidad lo usamos constantemente. Piensa en:
- Un Cajero Automático: Siempre está "encendido" esperando a un cliente. Cuando termina con uno, vuelve al principio. Solo se apaga si un técnico mete una clave especial.
- Un Videojuego: El programa corre constantemente hasta que tú pulsas "Salir al menú principal".

El compañero inseparable: `**El break**`

Como no queremos que el programa se quede trabado para siempre y bloquee tu computadora, necesitamos una puerta de emergencia. Esa puerta es la palabra clave break.

Anatomía de un while True profesional:
"""

while True:  # 1. Inicio el bucle infinito
    accion = input("¿Qué quieres hacer? (escribe 'stop' para salir): ")

    if accion == "stop": # 2. La condición de salida
        print("Saliendo del bucle...")
        break # 3. El martillo que rompe el bucle

    print(f"Has elegido: {accion}") # 4. El código que se repite

"""**Diferencia clave: while condicion vs while True**

- *while condicion:* Se usa cuando la regla de salida es simple (ej. un número llega a un límite). Se comprueba al principio de cada vuelta.
- *while True*: Se usa cuando la regla de salida es compleja o puede ocurrir en cualquier momento dentro del código. Te da más control porque tú decides exactamente en qué línea poner el break.

##**3. Control de Bucles: break y continue**

A veces necesitas alterar el flujo normal de un bucle:
- **break**: Rompe el bucle por completo y sale de él inmediatamente.
- **continue**: Salta el resto del código en la iteración actual y pasa directamente a la siguiente "vuelta".
"""

#EJEMPLO DE BREAK.#
expedientes = [101, 102, 103, 104, 105]
for num in expedientes:
    if num == 103:
        print(f"¡Expediente {num} encontrado! Deteniendo búsqueda...")
        break  # El bucle se detiene aquí. No llegará al 104 ni al 105.
    print(f"Revisando expediente {num}...")
print("Bucle finalizado.")

#EJEMPLO DE CONTINUE.#
# Queremos imprimir solo los números impares
numeros = [1, 2, 3, 4, 5]
for n in numeros:
    if n % 2 == 0:  # Si el número es par
        continue    # Salta esta vuelta y ve al siguiente número
    print(f"Procesando número impar: {n}")

"""#9.EL ALCANCE EN PYTHON.

En Python, el alcance determina el punto en el que se puede acceder a una variable. Es lo que controla su duración y cómo se resuelve en las diferentes partes del código.

Para determinar correctamente el alcance, Python sigue la regla LEGB , que significa lo siguiente:

- Ámbito local (L) : Variables definidas en funciones o clases.

- Ámbito envolvente (E) : Variables definidas en funciones envolventes o anidadas.

- Ámbito global (G): Variables definidas en el nivel superior del módulo o archivo.

- Ámbito incorporado (B) : Nombres reservados en Python para funciones, módulos, palabras clave y objetos predefinidos.

Python usa la regla LEGB para determinar el alcance de las variables de tu programa. Analizaremos cada una de estas reglas para que comprendas mejor el proceso.

###**El ámbito local**

El ámbito local significa que a una variable declarada dentro de una función o clase solo se puede acceder dentro de esa función o clase.

He aquí un ejemplo:
"""

def my_func():
    my_var = 10
    print(my_var)

"""En este caso, la función my_func tiene su propio alcance, al que no se puede acceder desde fuera de ella. Al llamar, my_func se generará 10, pero al imprimir my_var fuera de la función se generará `NameError`:"""

def my_func():
    my_var = 10 # Locally scoped to my_func
    print(my_var)

my_func() # 10

print(my_var) # NameError: name 'my_var' is not defined

"""###**El ámbito envolvente**

El ámbito envolvente significa que una función que está anidada dentro de otra función puede acceder a las variables de la función dentro de la cual está anidada.

Por ejemplo:
"""

def outer_func():
    msg = 'Hello there!'

    def inner_func():
        print(msg)

    inner_func()

outer_func() # Hello there!

"""En este ejemplo, la función interna, inner_func, puede acceder libremente a la msgvariable definida en la función externa, outer_func. Sin embargo, tenga en cuenta que las funciones externas no pueden acceder a las variables definidas dentro de ninguna función anidada:"""

def outer_func():
    msg = 'Hello there!'
    print(res)

    def inner_func():
        res = 'How are you?'
        print(msg)

    inner_func()

outer_func() # NameError: name 'res' is not defined

"""Esto se debe a que `res` su alcance local es `inner_func`. Además, observe que outer_func intenta imprimir resantes de inner_func que se llame a .

Una solución es inicializar res como una cadena vacía en el ámbito que la contiene, que está dentro de **[nombre de la variable outer_func]**. Luego, dentro de **[nombre de la variable]** inner_func, crear res, una variable no local con la `nonlocal` palabra clave:
"""

def outer_func():
    msg = 'Hello there!'
    res = ""  # Declare res in the enclosing scope

    def inner_func():
        nonlocal res  # Allow modification of an enclosing variable
        res = 'How are you?'
        print(msg)  # Accessing msg from outer_func()

    inner_func()
    print(res)  # Now res is accessible and modified

outer_func()

# Output:
# Hello there!
# How are you?

"""###**El ámbito global.**

El ámbito global se refiere a las variables declaradas fuera de cualquier función o clase, a las que se puede acceder desde cualquier parte del programa. En este caso, my_varse puede acceder desde cualquier lugar, incluso dentro de una función en la que no está definida:
"""

my_var = 100

def show_var():
    print(my_var)

show_var() # 100
print(my_var) # 100

"""Y si quieres que una variable de ámbito local definida dentro de una función sea accesible globalmente, puedes usar la palabra clave `global`:"""

my_var_1 = 7

def show_vars():
    global my_var_2
    my_var_2 = 10
    print(my_var_1)
    print(my_var_2)

show_vars() # 7 10

# my_var_2 is now a global variable and can be accessed anywhere in the program
print(my_var_2) # 10

"""###**El ámbito integrado.**

Finalmente, el ámbito integrado se refiere a todas las funciones, módulos y palabras clave integrados de Python, y están disponibles en cualquier parte de su programa:
"""

print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False

"""# -TRUCOS DE PYTHON.-

1. Comentarios

Los comentarios son líneas de texto que son ignoradas por el intérprete de Python al ejecutar el código
"""

# Este es un comentario

"""2. Concatenación

Combina (concatena) cadenas.
"""

#Sintaxis:
cadena_concatenada = cadena1 + cadena2

#Ejemplo:
resultado = "Hola" + " John"</td>

"""3. Tipos de Datos

    - Entero
    - Flotante
    - Booleano
    - Cadena
"""

x=7
# Valor Entero
y=12.4
# Valor Flotante
es_valido = True
# Valor Booleano
es_valido = False
# Valor Booleano
Nombre = "John"
# Valor de Cadena

"""4. Indexación

Accede al carácter en un índice específico.
"""

mis_cadenas="Hola"
caracter = mis_cadenas[0]
print(caracter)

"""5. `len()	`

Devuelve la longitud de una cadena.
"""

#Sintaxis:
len(nombre_cadena)

#Ejemplo:
mis_cadenas="Hola"
longitud = len(mis_cadenas)
print(longuitud)

"""6. `lower()	`

Convierte la cadena a minúsculas.
"""

mis_cadenas="Hola"
texto_minusc = mis_cadenas.lower()

"""7. `print()`

Imprime el mensaje o variable dentro de `()`.
"""

print("Hola, mundo")
print("a+b")

"""8. Operadores de Python
    - Adición (+): Suma dos valores.
    - Sustracción (-): Resta un valor de otro.
    - Multiplicación (*): Multiplica dos valores.
    - División (/): Divide un valor por otro, devuelve un flotante.
    - División entera (//): Divide un valor por otro, devuelve el cociente como un entero.
    - Módulo (%): Devuelve el residuo después de la división.
"""

x = 9 y = 4
resultado_suma= x + y # Adición
resultado_resta= x - y # Sustracción
resultado_multiplicacion= x * y # Multiplicación
resultado_division= x / y # División
resultado_division_entera= x // y # División entera
resultado_modulo= x % y # Módulo</td>

"""9. `replace()	`

Reemplaza subcadenas.
"""

mis_cadenas="Hola"
nuevo_texto = mis_cadenas.replace("Hola", "Wola")
print(nuevo_texto)

"""10. Segmentación

Extrae una porción de la cadena.
"""

#Sintaxis:
subcadena = nombre_cadena[inicio:fin]

#Ejemplo:
mis_cadenas="Hola" subcadena = mis_cadenas[0:5]

"""11. `split()	`

Divide la cadena en una lista basada en un delimitador.
"""

mis_cadenas="Hola amigo"
texto_dividido = mis_cadenas.split("/")
print(texto_dividido)

"""12. `strip()`

Elimina espacios en blanco al inicio y al final.
"""

mis_cadenas=" Hola "
recortado = mis_cadenas.strip()
print(recortado)

"""13. `upper()`

Convierte la cadena a mayúsculas.
"""

mis_cadenas="Hola"
texto_mayusc = mis_cadenas.upper()

"""14. Asignación de Variables

Asigna un valor a una variable.
"""

#Sintaxis:
nombre_variable = valor

#Ejemplo:
nombre="John" # asignando John a la variable nombre
x = 5 # asignando 5 a la variable x

"""15. `append()`

El método `append()` se utiliza para agregar un elemento al final de una lista.
"""

#Sintaxis:
list_name.append(element)

#Ejemplo:
fruits = ["manzana", "plátano", "naranja"]
fruits.append("mango") print(fruits)

"""16. `copy()`

El método `copy()` se utiliza para crear una copia superficial de una lista.
"""

my_list = [1, 2, 3, 4, 5]
new_list = my_list.copy()
print(new_list)
# Salida: [1, 2, 3, 4, 5]

"""17. `count()	`

El método `count()` se utiliza para contar el número de ocurrencias de un elemento específico en una lista en Python.
"""

my_list = [1, 2, 2, 3, 4, 2, 5, 2]
count = my_list.count(2)
print(count)
# Salida: 4

"""18. Crear una lista.

Una lista es un tipo de dato incorporado que representa una colección ordenada y mutable de elementos. Las listas están encerradas entre corchetes [] y los elementos están separados por comas.
"""

fruits = ["manzana", "plátano", "naranja", "mango"]

"""19. `del`

La instrucción `del` se utiliza para eliminar un elemento de la lista. La instrucción `del` elimina el elemento en el índice especificado.
"""

my_list = [10, 20, 30, 40, 50]
del my_list[2] # Elimina el elemento en el índice 2
print(my_list)
# Salida: [10, 20, 40, 50]

"""20. `extend()	`

El método `extend()` se utiliza para agregar múltiples elementos a una lista. Toma un iterable (como otra lista, tupla o cadena) y agrega cada elemento del iterable a la lista original.
"""

#Sintaxis:
list_name.extend(iterable)

#Ejemplo:
fruits = ["manzana", "plátano", "naranja"]
more_fruits = ["mango", "uva"]
fruits.extend(more_fruits)
print(fruits)

"""21. `Insert()	`

El método `insert()` se utiliza para insertar un elemento.
"""

#Sintaxis:
list_name.insert(index, element)

#Ejemplo:
my_list = [1, 2, 3, 4, 5]
my_list.insert(2, 6)
print(my_list)

"""22. Modificar una lista.

Puedes usar la indexación para modificar o asignar nuevos valores a elementos específicos en la lista.
"""

my_list = [10, 20, 30, 40, 50]
my_list[1] = 25 # Modificando el segundo elemento
print(my_list)
# Salida: [10, 25, 30, 40, 50]

"""23. `pop()	`

El método `pop()` es otra forma de eliminar un elemento de una lista en Python. Elimina y devuelve el elemento en el índice especificado. Si no proporcionas un índice al método `pop()`, eliminará y devolverá el último elemento de la lista por defecto.
"""

#Ejemplo 1:
my_list = [10, 20, 30, 40, 50]
removed_element = my_list.pop(2) # Elimina y devuelve el elemento en el índice 2
print(removed_element)
# Salida: 30
print(my_list)
# Salida: [10, 20, 40, 50]

#Ejemplo 2:
my_list = [10, 20, 30, 40, 50]
removed_element = my_list.pop() # Elimina y devuelve el último elemento
print(removed_element)
# Salida: 50
print(my_list)
# Salida: [10, 20, 30, 40]

"""24. `remove()`

Para eliminar un elemento de una lista. El método `remove()` elimina la primera ocurrencia del valor especificado.
"""

my_list = [10, 20, 30, 40, 50]
my_list.remove(30) # Elimina el elemento 30
print(my_list)
# Salida: [10, 20, 40, 50]

"""25. `reverse()	`

El método `reverse()` se utiliza para invertir el orden de los elementos en una lista.
"""

my_list = [1, 2, 3, 4, 5]
my_list.reverse()
print(my_list)
# Salida: [5, 4, 3, 2, 1]

"""26. `sort()`

El método `sort()` se utiliza para ordenar los elementos de una lista en orden ascendente. Si deseas ordenar la lista en orden descendente, puedes pasar el argumento `reverse=True` al método `sort()`.
"""

#Ejemplo 1:
my_list = [5, 2, 8, 1, 9]
my_list.sort()
print(my_list)
# Salida: [1, 2, 5, 8, 9]

#Ejemplo 2:
my_list = [5, 2, 8, 1, 9]
my_list.sort(reverse=True)
print(my_list)
# Salida: [9, 8, 5, 2, 1]